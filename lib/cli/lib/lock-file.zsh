#!/usr/bin/env zsh
# Lock file operations for Pulse plugin manager
# Provides reproducible plugin installations via plugins.lock file

# Lock file format: INI-style with plugin sections
# Version: 1.0.0

# Initialize lock file with header
# Usage: pulse_init_lock_file
pulse_init_lock_file() {
  local lock_file="${PULSE_LOCK_FILE:-${PULSE_DIR}/plugins.lock}"
  local lock_dir="${lock_file:h}"

  # Ensure directory exists
  mkdir -p "$lock_dir"

  # Write header
  cat > "$lock_file" <<'EOF'
# Pulse Plugin Lock File
# Version: 1.0.0
# Generated: %TIMESTAMP%
#
# DO NOT EDIT THIS FILE MANUALLY
# This file is automatically generated to ensure reproducible plugin installations.
#
# Format: INI-style with one section per plugin
# Each section contains:
#   url      - Git repository URL
#   ref      - Branch, tag, or empty for default branch
#   commit   - Exact commit SHA that was installed
#   timestamp - When this plugin was locked
#   stage    - Loading stage (early, path, fpath, completions, defer)

EOF

  # Replace placeholder with actual timestamp
  local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || date -u +"%Y-%m-%dT%H:%M:%S" 2>/dev/null || echo "unknown")
  sed -i.bak "s/%TIMESTAMP%/${timestamp}/" "$lock_file" 2>/dev/null || \
    sed -i '' "s/%TIMESTAMP%/${timestamp}/" "$lock_file" 2>/dev/null || \
    true
  rm -f "${lock_file}.bak" 2>/dev/null

  return 0
}

# Write a lock entry for a plugin
# Usage: pulse_write_lock_entry <plugin_name> <url> <ref> <commit> <timestamp> <stage>
pulse_write_lock_entry() {
  local plugin_name="$1"
  local url="$2"
  local ref="$3"
  local commit="$4"
  local timestamp="$5"
  local stage="$6"

  local lock_file="${PULSE_LOCK_FILE:-${PULSE_DIR}/plugins.lock}"

  # Initialize lock file if it doesn't exist
  if [[ ! -f "$lock_file" ]]; then
    pulse_init_lock_file
  fi

  # Append plugin section in INI format
  cat >> "$lock_file" <<EOF

[${plugin_name}]
url = ${url}
ref = ${ref}
commit = ${commit}
timestamp = ${timestamp}
stage = ${stage}
EOF

  return 0
}

# Read lock file and list all locked plugins
# Usage: pulse_read_lock_file
# Returns: Array of plugin names (one per line)
pulse_read_lock_file() {
  local lock_file="${PULSE_LOCK_FILE:-${PULSE_DIR}/plugins.lock}"

  # Check if lock file exists
  if [[ ! -f "$lock_file" ]]; then
    return 1
  fi

  # Extract plugin names from INI sections
  # Match lines like [plugin-name]
  grep -E '^\[.+\]$' "$lock_file" | sed 's/^\[\(.*\)\]$/\1/'

  return 0
}

# Read lock entry for a specific plugin
# Usage: pulse_read_lock_entry <plugin_name>
# Returns: Space-separated values: url ref commit timestamp stage
pulse_read_lock_entry() {
  local plugin_name="$1"
  local lock_file="${PULSE_LOCK_FILE:-${PULSE_DIR}/plugins.lock}"

  # Check if lock file exists
  if [[ ! -f "$lock_file" ]]; then
    return 1
  fi

  # Find the plugin section and extract values
  awk -v plugin="$plugin_name" '
    /^\[/ { in_section = 0 }
    $0 == "[" plugin "]" { in_section = 1; next }
    in_section && /^url = / { url = substr($0, 7) }
    in_section && /^ref = / { ref = substr($0, 7) }
    in_section && /^commit = / { commit = substr($0, 10) }
    in_section && /^timestamp = / { timestamp = substr($0, 13) }
    in_section && /^stage = / { stage = substr($0, 9) }
    END {
      if (url) print url, ref, commit, timestamp, stage
    }
  ' "$lock_file"

  return 0
}

# Validate lock file format
# Usage: pulse_validate_lock_file
# Returns: 0 if valid, 1 if invalid (prints errors to stderr)
pulse_validate_lock_file() {
  local lock_file="${PULSE_LOCK_FILE:-${PULSE_DIR}/plugins.lock}"
  local errors=0

  # Check if file exists
  if [[ ! -f "$lock_file" ]]; then
    echo "Error: Lock file not found: $lock_file" >&2
    return 1
  fi

  # Check for version header
  if ! grep -q "# Version:" "$lock_file"; then
    echo "Warning: Lock file missing version header" >&2
    ((errors++))
  fi

  # Validate each plugin section has required fields using awk
  # This is more reliable than shell-based section extraction
  local validation_errors=$(awk '
    /^\[.+\]$/ {
      # Validate previous section
      if (plugin) {
        if (!has_url) print "Error: Plugin '\''" plugin "'\'' missing '\''url'\'' field"
        if (!has_commit) print "Error: Plugin '\''" plugin "'\'' missing '\''commit'\'' field"
        if (!has_stage) print "Error: Plugin '\''" plugin "'\'' missing '\''stage'\'' field"
      }
      # Start new section
      plugin = substr($0, 2, length($0) - 2)
      has_url = 0
      has_commit = 0
      has_stage = 0
    }
    /^url[[:space:]]*=/ { has_url = 1 }
    /^commit[[:space:]]*=/ { has_commit = 1 }
    /^stage[[:space:]]*=/ { has_stage = 1 }
    END {
      # Validate last section
      if (plugin) {
        if (!has_url) print "Error: Plugin '\''" plugin "'\'' missing '\''url'\'' field"
        if (!has_commit) print "Error: Plugin '\''" plugin "'\'' missing '\''commit'\'' field"
        if (!has_stage) print "Error: Plugin '\''" plugin "'\'' missing '\''stage'\'' field"
      }
    }
  ' "$lock_file")

  if [[ -n "$validation_errors" ]]; then
    echo "$validation_errors" >&2
    local error_count=$(echo "$validation_errors" | wc -l | tr -d ' ')
    errors=$((errors + error_count))
  fi

  if [[ $errors -gt 0 ]]; then
    echo "Lock file validation failed with $errors error(s)" >&2
    return 1
  fi

  return 0
}

# Remove a plugin entry from lock file
# Usage: pulse_remove_lock_entry <plugin_name>
pulse_remove_lock_entry() {
  local plugin_name="$1"
  local lock_file="${PULSE_LOCK_FILE:-${PULSE_DIR}/plugins.lock}"

  if [[ ! -f "$lock_file" ]]; then
    return 0  # Nothing to remove
  fi

  # Create temporary file
  local temp_file="${lock_file}.tmp"

  # Copy all content except the specified plugin section
  awk -v plugin="$plugin_name" '
    /^\[/ { in_section = 0 }
    $0 == "[" plugin "]" { in_section = 1; next }
    !in_section { print }
  ' "$lock_file" > "$temp_file"

  # Replace original with filtered content
  mv "$temp_file" "$lock_file"

  return 0
}
